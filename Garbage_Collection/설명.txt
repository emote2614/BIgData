## 가비지 컬렉션

- 프로그래밍 언어에서 자동으로 메모리를 관리하는 기능
- 파이썬에 내장되어 있으며, 개발자가 명시적으로 메모리를 해제할 필요 없음
- 동적으로 할당된 메모리 중에서 더 이상 사용되지 않는 객체를 탐지하고,
해당 객체가 사용하는 메모리를 해제하는 프로세스를 의미
- 이를 통해 프로그램이 불필요한 메모리를 차지하지 않도록 관리하며, 메모리 누수 방지

### 필요성

1. 메모리 누수 방지
    1. 가비지 컬렉션은 개발자가 명시적으로 메모리를 해제하는 작업을 하지 않아도 됨
    2. 개발자의 실수(메모리 해제 실수, 잘모된 타이밍 해제)를 방지할 수 있도록 함


2. 편의성과 생산성
    1. 개발자가 메모리 관리에 대한 부담을 덜어줌
    2. 메모리 할당 및 해제를 자동으로 처리하므로, 개발자는 메모리 관리에 대한 복잡한 로직을 작성안해도 됨

### 매커니즘

1. 참조 카운팅(Reference Counting)
    1. 객체를 참조하는 변수의 수를 추적하여 해당 객체가 참조되는 횟수를 카운트
    2. 객체를 참조하는 변수가 존재하는 동안은 참조 카운트가 증가,
    변수가 해당 객체를 참조하지 않으면 참조 카운트 감소
    3. 참조 카운트가 0이 되면 해당 객체는 더이상 사용되지 않으므로 가비지로 간주
        <장점>
            1. 객체가 더 이상 사용되지 않을 떄 즉시 메모리에서 해제 -> 메모리 누수 방지 + 메모리 관리 효율적
            2. 참조 카운팅을 이용한 메모리 해제는 간단 + 빠름
        <단점>
            1. 두 개 이상의 객체가 서로를 참조하는 경우 참조 카운트가 0이 되지 않아 메모리가 해제가
                제대로 이루어지지 않을 수 있어 순환 참조르 ㄹ감지하고 해제해주는 가비지 컬렉션 기법이 필요
            2. 참조 카운트 자체에 오버헤드가 발생함으로써 성능 저하 발생 가능
            3. 여러 스레드가 동시에 동일한 객체에 접근하여 참조 카운트를 증가 또는 감소시킬 경우,
                동기화 문제로 인해 정확한 참조 카운트를 유지하기 어려움

2. 순환 참조 검사
    1. 참조 카운팅만으로는 순환 참조되는 객체를 해제할 수 없음
    2. 객체들을 도달 가능한 객체와 도달 불가능한 객체로 구분하여, 도달 불가능한 객체들을 가비지로 처리
        <장점>
            1. 순환 참조와 같이 복잡한 상황에서도 메모리 누수를 방지할 수 있음
            2. 개발자가 명시적으로 메모리 관리를 신경쓰지 않아도 됨
        <단점>
            1. 추가적인 오버헤드가 발생할 수 있으며 객체의 도달 가능성을 추적하고,
                도달 불가능한 객체를 식별하고, 해제하는 과정에서 비용이 소요
            2. 가비지 컬렉션의 실행 시점을 예측하기 어려워 가비지 컬렉션 실행 도중에는 
                프로그램 실행이 일시적으로 중단될 수 있음